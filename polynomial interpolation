distribute = lambda list, factor: list if list == [] else [factor*list[0]] + distribute(list[1:], factor)
evalPoly = lambda list: (lambda x: 0) if list == [] else lambda x: list[0] + x*evalPoly(list[1:])(x)
addPoly = lambda list1, list2: list2 if list1 == [] else (list1 if list2 == [] else [list1[0] + list2[0]] + addPoly(list1[1:], list2[1:]))
multPoly = lambda list1, list2: [] if list2 == [] else addPoly(distribute(list1, list2[0]), [0]+multPoly(list1, list2[1:]))
lagrangeBasisHelper = lambda list, j, count: [] if list == [] else ([1] if count == len(list) else (lagrangeBasisHelper(list,j,count+1) if j == count else multPoly(distribute([-1*list[count][0],1], 1/(list[j][0]-list[count][0])), lagrangeBasisHelper(list,j,count+1))))
lagrangeBasis = lambda list, j: lagrangeBasisHelper(list,j,0)
lagrangePolyHelper = lambda list, j: [] if j == len(list) else addPoly(distribute(lagrangeBasis(list,j), list[j][1]), lagrangePolyHelper(list,j+1))
limitList = lambda f, x, y: [f(x)] if abs(y-x) <= 0.0001 else [f(x)] + limitList(f, (x+y)/2, y)
limit = lambda f, a, b: [f((a+b)/2)] if abs(f(a) - f((a+b)/2)) <= 0.00001 else limit(f, (a+b)/2, b)
derivative = lambda f, x: limit(lambda y: (f(x)-f(y))/(x-y), x-2, x)
fxPoints = lambda f, a, b, i: [] if a >= b else [[a, f(a)]] + fxPoints(f, a+i, b, i)
limit = lambda f, a, b: f((a+b)/2) if abs(b-((a+b)/2))<0.000001 else limit(f, (a+b)/2, b)
limitList = lambda f, start, end: [f(start)] if abs(start-end)<0.000001 else limitList(f, (start+end)/2, end) + [f(start)]
derivative = lambda f, a: limit(lambda x: (f(x)-f(a))/(x-a), a-1, a)
polyToStr = lambda list: "" if list == [] else (str(list[len(list)-1]) + "x + " + polyToStr(list[:len(list)-1]) if len(list) == 2 else (str(list[0]) + polyToStr(list[:len(list)-1]) if len(list) == 1 else str(list[len(list)-1]) + "x^" + str(len(list)-1) + " + " + polyToStr(list[:len(list)-1])))
polyToStr(lagrangePoly(fxPoints(lambda a: derivative(lambda x: math.sin(x),a), 0, 4, 3.1415/4)))
transform = lambda f, a, b, c, d: lambda x: f(x-(c-a)) + (d-b)
periodHelper = lambda f, a, b, x: f(x) if x >= a and x < b else (periodHelper(f,a,b,x+(b-a)) if x<a else periodHelper(f,a,b,x-(b-a)))
period = lambda f, a, b: lambda x: periodHelper(f, a, b, x)
period = lambda f, a, b: lambda x: f(x) if x>=a and x<b else (period(lambda y: f(y+(b-a)), a-(b-a), a)(x) if x<a else period(lambda y: f(y-(b-a)), b, b+(b-a))(x))
period(evalPoly(lagrangePoly(fxPoints(math.sin, 0, 6.5, 3.1415/6))), 0, 6.283185)
sinApprox = period(evalPoly(lagrangePoly(fxPoints(math.sin, 0, 2*math.pi, 3.1415/6))), 0, 2*math.pi)
inaccuracyList = lambda f, approxF, a, b: [] if a>b else ([a] + inaccuracyList(f, approxF, a+0.001, b) if f(a)-approxF(a) > 0.000001 else inaccuracyList(f, approxF, a+0.001, b))
valueSum = lambda f, start, end: 0 if start>end else f(start) + valueSum(f, start+0.0001, end)
valueSum(lambda x: math.sin(x)-sinApprox(x), 0, 2*math.pi, 0.001)
accuracyCounter = lambda f, approxF, a, b: 0 if a>b else (1 + accuracyCounter(f, approxF, a+0.001, b) if f(a)-approxF(a) > 0.000001 else accuracyCounter(f, approxF, a+0.001, b))
accuracyCounter(math.sin, sinApprox, 0, 2*math.pi)
